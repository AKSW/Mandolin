package mlnf.inference;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;

import mlnf.controller.NameMapper;
import mlnf.model.PredictionLiteral;
import mlnf.model.PredictionSet;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.googlecode.rockit.app.solver.pojo.Clause;
import com.googlecode.rockit.app.solver.pojo.Literal;
import com.googlecode.rockit.exception.ParseException;
import com.googlecode.rockit.exception.SolveException;
import com.hp.hpl.jena.vocabulary.OWL;

/**
 * Manager for the Gibbs-Sampling inference. Ground rules can be extracted from
 * the Postgre database after being generated by ProbKB (faster) or generated
 * through standard grounding by RockIt (slower).
 * 
 * @author author <email>
 *
 */
public class ProbKBToRockitGibbsSampling extends RockitGibbsSampling {

	private final static Logger logger = LogManager.getLogger(ProbKBToRockitGibbsSampling.class);
	
	public static void main(String[] args) {

		PredictionSet ps = new ProbKBToRockitGibbsSampling(
				new NameMapper(OWL.sameAs.getURI())).infer(null);
		for (PredictionLiteral lit : ps)
			logger.info(lit);

	}

	public ProbKBToRockitGibbsSampling(NameMapper map) {
		super(map);			
	}

	/**
	 * Call ProbKB for grounding and preprocess its input for Gibbs sampling by
	 * RockIt.
	 */
	public PredictionSet infer(Integer sampling) {
		
		Factors factors = Factors.getInstance();
		factors.preprocess(map.getAimName());

		// +++ STARTING POINTS +++
		// Prop2|alb|nob
		ArrayList<String> consistentStartingPoints = factors
				.getConsistentStartingPoints();

		// +++ CLAUSES +++
		// Clause [weight=0.0, restriction=[[Prop2|b|e]], hard=true]
		ArrayList<Clause> clauses = factors.getClauses();

		// +++ EVIDENCE +++
		// [Prop2|2db|h0e]
		Collection<Literal> evidence = factors.getEvidence();

		logger.debug("Evidence: "+evidence);

		// call Gibbs sampler
		PredictionSet ps = null;
		try {
			ps = gibbsSampling(consistentStartingPoints, clauses, evidence, sampling);
		} catch (SQLException | SolveException | ParseException e) {
			e.printStackTrace();
		}

		return ps;
	}

}
