package org.aksw.mandolin.rockit;

import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;

import org.aksw.mandolin.model.PredictionLiteral;

import com.googlecode.rockit.app.Parameters;
import com.googlecode.rockit.app.sampler.gibbs.GIBBSLiteral;
import com.googlecode.rockit.app.sampler.gibbs.GIBBSSampler;
import com.googlecode.rockit.app.solver.StandardSolver;
import com.googlecode.rockit.app.solver.pojo.Clause;
import com.googlecode.rockit.app.solver.pojo.Literal;
import com.googlecode.rockit.exception.ParseException;
import com.googlecode.rockit.exception.ReadOrWriteToFileException;
import com.googlecode.rockit.exception.SolveException;
import com.googlecode.rockit.javaAPI.Model;
import com.googlecode.rockit.parser.SyntaxReader;

/**
 * Manager for the Gibbs-Sampling inference. Ground rules can be extracted from
 * the Postgre database after being generated by ProbKB (faster) or generated
 * through standard grounding by RockIt (slower).
 * 
 * @author Tommaso Soru <tsoru@informatik.uni-leipzig.de>
 *
 */
public class GibbsSampling {

	/**
	 * MLN file.
	 */
	private String input;

	/**
	 * DB file.
	 */
	private String groundings;

	private static SyntaxReader reader;
	private Model model;

	// Sampling only
	/**
	 * The number of iterations for sampling.
	 */
	public static final int ITERATIONS = 5000000;
	private GIBBSSampler gibbsSampler;

	public static void main(String[] args) {

		// launch test
		try {
			new GibbsSampling("eval/11_publi-mln/prog.mln",
					"eval/11_publi-mln/evidence.db")
					.inferAfterGroundingByRockIt();
//					.inferAfterGroundingByProbKB();
		} catch (ParseException | SolveException | SQLException
				| ReadOrWriteToFileException | IOException e) {
			e.printStackTrace();
		}

	}

	public GibbsSampling(String input, String groundings)
			throws ReadOrWriteToFileException, ParseException, IOException {

		this.input = input;
		this.groundings = groundings;

		Parameters.readPropertyFile();
		Parameters.USE_CUTTING_PLANE_AGGREGATION = false;
		Parameters.USE_CUTTING_PLANE_INFERENCE = false;
		reader = new SyntaxReader();

	}

	/**
	 * Call ProbKB for grounding and preprocess its input for Gibbs sampling by
	 * RockIt.
	 * 
	 * @throws ParseException
	 * @throws SolveException
	 * @throws SQLException
	 * @throws IOException 
	 */
	public void inferAfterGroundingByProbKB() throws ParseException,
			SolveException, SQLException, IOException {

		System.out.println("Input: " + this.input);

		// TODO make the following three collections out of ProbKB input
		
//		+++ STARTING POINTS +++
//		Prop2|alb|nob
		ArrayList<String> consistentStartingPoints = null;
		
//		+++ CLAUSES +++
//		Clause [weight=0.0, restriction=[[Prop2|b|e]], hard=true]
		ArrayList<Clause> clauses = null;
		
//		+++ EVIDENCE +++
//		[Prop2|2db|h0e]
		Collection<Literal> evidence = null;
		
		System.out.println(evidence);

		// call Gibbs sampler
		gibbsSampling(consistentStartingPoints, clauses, evidence);

	}

	/**
	 * Call RockIt for both standard grounding and Gibbs-sampling inference.
	 * 
	 * @throws ParseException
	 * @throws IOException
	 * @throws SolveException
	 * @throws SQLException
	 */
	public void inferAfterGroundingByRockIt() throws ParseException,
			SolveException, SQLException, IOException {

		model = reader.getModel(input, groundings);

		// standard grounding...
		System.out.println("Input: " + this.input);
		StandardSolver solver = new StandardSolver(model);
		// ground MLN and retrieve Clauses
		ArrayList<String> consistentStartingPoints = solver.solve();
		System.out.println("+++ STARTING POINTS +++");
		for(String s : consistentStartingPoints)
			System.out.println(s);
		ArrayList<Clause> clauses = solver.getAllClauses();
		System.out.println("+++ CLAUSES +++");
		for(Clause c : clauses)
			System.out.println(c);
		Collection<Literal> evidence = solver.getEvidenceAxioms();
		System.out.println("+++ EVIDENCE +++");
		for(Literal l : evidence)
			System.out.println(l);
		solver = null; // free memory

		// call Gibbs sampler
		gibbsSampling(consistentStartingPoints, clauses, evidence);

	}

	/**
	 * Gibbs Sampling by RockIt.
	 * 
	 * @param consistentStartingPoints
	 * @param clauses
	 * @param evidence
	 * @throws SQLException
	 * @throws SolveException
	 * @throws ParseException
	 */
	public void gibbsSampling(ArrayList<String> consistentStartingPoints,
			ArrayList<Clause> clauses, Collection<Literal> evidence)
			throws SQLException, SolveException, ParseException {

		gibbsSampler = new GIBBSSampler();
		ArrayList<GIBBSLiteral> gibbsOutput = gibbsSampler.sample(ITERATIONS,
				clauses, evidence, consistentStartingPoints);

		// TODO remove me later
		System.out.println();
		for (Clause c : clauses) {
			System.out.println(c);
		}

		for (GIBBSLiteral l : gibbsOutput) {
			PredictionLiteral lit = new PredictionLiteral(l);
			System.out.println(lit);
		}

		// TODO return something evaluable

	}

}
